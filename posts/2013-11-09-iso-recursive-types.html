<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title> C&amp;C -  Fixpoints and Iso-recursive Types</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../"> Code &amp; Co. </a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Blog</a>
            </div>
        </div>

        <div id="content">
            <h1>Fixpoints and Iso-recursive Types</h1>
            <div class="info">
    Posted on November  9, 2013
    
</div>

<p>Let’s imagine a world where Haskell didn’t have recursive functions. The Haskell committee simply left them out by mistake. Could Haskell still be Turing complete?</p>
<p>Well we need some method of arbitrary recursion, let’s try what we’d do in lambda calculus: fixpoints. In particular, we want a function like this</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</code></pre>
<h3 id="what-are-fixpoints">What are fixpoints?</h3>
<p>So we pass in a function <code>f</code>, and it will return to us a value <code>a</code> so that <code>f a = a</code>. Why is this useful? Imagine we encode recursive functions like this</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    factorial ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)
              <span class="ot">-&gt;</span> <span class="dt">Int</span>
              <span class="ot">-&gt;</span> <span class="dt">Int</span>
    factorial self <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span>
    factorial self n <span class="fu">=</span> n <span class="fu">*</span> self (n<span class="fu">-</span><span class="dv">1</span>)</code></pre>
<p>So we pass along recursion through this extra function. Well here factorial is really a function of type</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    factorial ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</code></pre>
<p>And we want to fill it like this</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    completeFactorial n <span class="fu">=</span> factorial (factorial (factorial (factorial <span class="fu">...</span>))) n</code></pre>
<p>Now when we take the fixpoint, we find an <code>a</code> where <code>factorial a = a</code>. This means that</p>
<pre><code>factorial a = factorial (factorial a) = factorial (factorial (factorial ...)))</code></pre>
<p>So with fixpoints, we get that infinitely long chain that we wanted.</p>
<h3 id="fixpoints-with-recursion">Fixpoints with recursion</h3>
<p>If we allowed ourselves recursion for a moment then <code>fix</code> is easy</p>
<pre><code>fix f = let x = f x in x</code></pre>
<p>This looks silly, but in fact, if <code>f</code> isn’t strict in <code>x</code>, than <code>x</code> can be non-bottom. And if <code>f</code> is strict than by definition, <code>f ⊥ = ⊥</code> so <code>⊥</code> is a fixpoint.</p>
<h3 id="fixpoints-without-recursion">Fixpoints without recursion</h3>
<p>Now we can actually still write a fixpoint-finding function without recursion. The most famous one is the y-combinator. In lambda calculus, we’d write this as</p>
<pre><code>Y = λf . (λx . f (x x)) (λx . f (x x))</code></pre>
<p>And we want to show that <code>Y f = f (Y f)</code></p>
<pre><code>Y f = f (Y f)
(λx . f (x x)) (λx . f (x x)) = f ((λx . f (x x)) (λx . f (x x)))
f((λx . f (x x)) (λx . f (x x))) = f ((λx . f (x x)) (λx . f (x x)))</code></pre>
<p>With simple beta reduction, they’re equal.</p>
<h4 id="fixpoints-in-haskell">Fixpoints in Haskell</h4>
<p>Now in Haskell, this doesn’t work. We could try</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    fix f <span class="fu">=</span> (\x <span class="ot">-&gt;</span> f (x x)) (\x <span class="ot">-&gt;</span> f (x x))</code></pre>
<p>But what is <code>x</code>’s type? Well it’s a function so</p>
<pre><code>x :: a -&gt; b</code></pre>
<p>And <code>x</code>’s first argument is <code>x</code>, so</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">type</span> <span class="dt">T</span> <span class="fu">=</span> <span class="dt">T</span> <span class="ot">-&gt;</span> b
    <span class="kw">type</span> <span class="dt">T</span> <span class="fu">=</span> μR<span class="fu">.</span> <span class="dt">R</span> <span class="ot">-&gt;</span> b <span class="co">-- This means the same as the above</span>
<span class="ot">    x ::</span> <span class="dt">T</span></code></pre>
<p>But this isn’t legal! We can’t have infinite types like that. Don’t despair though, we’re going to use the magic of iso-recursive types.</p>
<p>What are iso-recursive types? Well they’re like (equi-)recursive types, but they provide two operations, <code>fold</code> and <code>unfold</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    unfold ::</span> μX<span class="fu">.</span> <span class="dt">T</span> <span class="ot">-&gt;</span> [μX<span class="fu">.</span> <span class="dt">T</span><span class="fu">/</span><span class="dt">X</span>]<span class="dt">T</span>
<span class="ot">    fold   ::</span> [μX<span class="fu">.</span> <span class="dt">T</span><span class="fu">/</span><span class="dt">T</span>]<span class="dt">T</span> <span class="ot">-&gt;</span> μX<span class="fu">.</span> <span class="dt">T</span></code></pre>
<p>Where <code>[foo/bar]baz</code> means, “substitute all occurrences of <code>bar</code> with <code>foo</code> in <code>baz</code>. When trying to unify iso-recursive types, we don’t consider a type equal to an unfolding of that type. This makes type inference considerably easier since we’re requiring the user to explicitly fold and unfold types.</p>
<p>We can write these in Haskell</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="fu">=</span> <span class="dt">Mu</span> {<span class="ot">unMu ::</span> f (<span class="dt">Mu</span> f)}
    unfold <span class="fu">=</span> unMu
    fold   <span class="fu">=</span> <span class="dt">Mu</span></code></pre>
<p>Now we can write the type of <code>x</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">newtype</span> <span class="dt">X'</span> b a <span class="fu">=</span> {<span class="ot">unX ::</span> a <span class="ot">-&gt;</span> b}
    <span class="kw">type</span> <span class="dt">X</span> a <span class="fu">=</span> <span class="dt">Mu</span> (<span class="dt">X'</span> a)</code></pre>
<p>Take a moment to think about this, mentally unfolding we have</p>
<pre><code>X a
Mu (X' a)
Mu X' -&gt; a
(Mu X' -&gt; a) -&gt; a
...</code></pre>
<p>There we go! Now for that y combinator</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    unfold' <span class="fu">=</span> unX  <span class="fu">.</span> unfold
    fold'   <span class="fu">=</span> fold <span class="fu">.</span> <span class="dt">X'</span>
    y f <span class="fu">=</span> (\x <span class="ot">-&gt;</span> f (unfold' x x)) <span class="fu">$</span> fold' (\x <span class="ot">-&gt;</span> f (unfold' x x))</code></pre>
<p>and finally</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    fix <span class="fu">=</span> y</code></pre>
<p>And to test it</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    f <span class="fu">=</span> fix factorial <span class="co">-- From the way before</span>
    main <span class="fu">=</span> <span class="fu">mapM_</span> (<span class="fu">print</span> <span class="fu">.</span> f) [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]</code></pre>
<p>prints</p>
<pre><code>1
2
6
24
120</code></pre>
<p>Which means we’re successful, we’ve added back recursion to Haskell!</p>

        </div>
        <div id="footer">
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
