<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title> C&amp;C -  forall Means All!</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../"> Code &amp; Co. </a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Blog</a>
            </div>
        </div>

        <div id="content">
            <h1>forall Means All!</h1>
            <div class="info">
    Posted on October  6, 2013
    
</div>

<p>It seems like the every week on Stack Overflow there’s at least two questions about higher rank polymorphism (RankNTypes). So here’s a brief description of what they are and how to use them.</p>
<p>First, to turn them on</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="ot">{-# LANGUAGE RankNTypes #-}</span></code></pre>
<p>Now to write one</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">     demo ::</span> (forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>
     demo f <span class="fu">=</span> f <span class="ch">'a'</span> <span class="fu">+</span> f <span class="kw">True</span></code></pre>
<p>Now that <code>forall</code> means “this function is polymorphic and can be applied to any argument”. Notice we can’t do this without rank N types,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    uhoh ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>
    uhoh f <span class="fu">=</span> f <span class="ch">'a'</span> <span class="fu">+</span> f <span class="kw">True</span> <span class="co">-- Error cannot unify 'a' with Char</span></code></pre>
<p>Here’s how not to use it</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    demo <span class="fu">id</span></code></pre>
<p><code>id</code> here unifies with <code>Int -&gt; Int</code> which isn’t the necessary <code>forall a. a -&gt; Int</code>. To use it,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    demo (<span class="fu">const</span> <span class="dv">1</span>)</code></pre>
<p>Now this seems pretty clear right? It’s just to make it possible to pass polymorphic functions to other functions. Easy peasy :)</p>
<p>Now what does this mean?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">data</span> <span class="dt">Tricky</span> <span class="fu">=</span> <span class="dt">Tricky</span> (forall x<span class="fu">.</span> x <span class="ot">-&gt;</span> x)</code></pre>
<p>Well you’d be right if you realized that the only sane instantiation of this is</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    t <span class="fu">=</span> <span class="dt">Tricky</span> <span class="fu">id</span></code></pre>
<p>We need a function</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    arg ::</span> a <span class="ot">-&gt;</span> a</code></pre>
<p>It’s pretty clear that the only sane version of <code>arg</code> is <code>id</code>.</p>
<p>A harder one,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">type</span> <span class="dt">ReallyTricky</span> a b <span class="fu">=</span> forall f<span class="fu">.</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p>That’s right it just means that anything of type <code>ReallyTricky</code> knows how to take some arbitrary function, and lift it into <em>any</em> functor. And the caller gets to choose which one.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">    t ::</span> <span class="dt">ReallyTricky</span>
    t <span class="fu">=</span> <span class="fu">fmap</span></code></pre>
<p>That’s it! Just remember that <code>forall</code> is universal quantification. This means that you have to be able to support all possible instationations of that variable and the caller will choose which one.</p>
<p>Now suppose you want it the other way, you choose the instantiation and the caller has to handle it generically. Then you want <code>existential</code> quantification. A subject for another post.</p>

        </div>
        <div id="footer">
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
