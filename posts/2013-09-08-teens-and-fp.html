<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title> C&amp;C -  Teens and Functional Programming</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../"> Code &amp; Co. </a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Blog</a>
            </div>
        </div>

        <div id="content">
            <h1>Teens and Functional Programming</h1>
            <div class="info">
    Posted on September  8, 2013
    
</div>

<p>As a teenager who spends most of his time programming, I spend a lot of time interacting/teaching other teens interested in programming.</p>
<p>One thing that’s always bothered me is the lack of fellow teenage functional programmers. I’ve been wondering whether this is simply chance? Or is there something that makes functional programming bad for beginners? Especially teenage ones.</p>
<p>Well first let’s formally define what I mean by a functional language, the definition is always a bit fuzzy. When I refer to a functional language, I mean a language that:</p>
<ul>
<li>Has primarily immutable data (Convention or enforced)</li>
<li>Functions as first class values</li>
<li>Functions are primarily “pure functions”</li>
</ul>
<p>Notice that I left out</p>
<ul>
<li>Type Systems</li>
<li>Algebraic data types + Pattern matching</li>
<li>Purity</li>
</ul>
<h3 id="immutability">Immutability</h3>
<p>Perhaps immutability is the problem. It’s certainly weird to experienced imperative programmers. But what about for beginners?</p>
<p>I’d argue immutability is actually pretty natural for a new programmer. It means variables are just names for data. No more of that confusing “a variable is like a box that you can put values in” explanation. Especially once you get into subtleties like indirection mutation looks less appealing.</p>
<p>In the first course for computer science students at the University of Minnesota, there is a whole quiz filled with problems like this in Python:</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="co"># What is the output of</span>
    a = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
    b = a[<span class="dv">1</span>:]
    b[<span class="dv">1</span>] = <span class="dv">4</span>
    <span class="kw">print</span> a</code></pre>
<p>Once you have a whole quiz devoted to a topic, it’s safe to say that it’s confusing.</p>
<p>This class also taught Scheme, when it came time to explain <code>let</code>, the professor simply said</p>
<blockquote>
<p>This is <code>let</code>.</p>
<pre><code>(let ((a 1))
    (+ 1 a))</code></pre>
<p>Just substitute <code>a</code> for 1 within the parens.</p>
</blockquote>
<p>and that was that.</p>
<p>I’d posit that the reason is that with immutability you can simply substitute a name for its value and have unchanged semantics. With mutable variables, a variable is more than just it’s value.</p>
<p>Now that’s not to say immutability doesn’t get weird eventually, purely functional data structures do sometimes require some mental gymnastics, but there is certainly not more mental overhead than with imperative programming’s pervasive mutation.</p>
<h3 id="first-class-functions">First Class Functions</h3>
<p>I find it hard to believe that first class functions are the problem since they’re not that unique anymore. Python, Ruby, and JavaScript all have them and they’re hugely popular with beginners.</p>
<p>The other thing is that you can largely ignore them until you need them. No one will make you use map, you could write the stupid repetitive recursion out every time. Additionally, many languages provide some sort of construct to let you avoid <code>map</code>, <code>filter</code>, or whatever. For example, in Haskell</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="fu">filter</span> <span class="fu">even</span> <span class="fu">.</span> <span class="fu">map</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">$</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]
    [x <span class="fu">+</span> <span class="dv">1</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>], <span class="fu">even</span> x]</code></pre>
<p>Perfect for a beginner. In fact, Python stole these for precisely this reason.</p>
<p>Finally, they actually alleviate a lot of complexity. Look at anonymous classes and the strategy pattern. The whole thing is a very large, ugly hack for dealing with the lack of first class functions.</p>
<h3 id="pure-functions">Pure Functions</h3>
<p>This one isn’t too hard to argue. If you have some function <code>f</code>, if you call it</p>
<pre><code>a = f(1);
b = f(1);</code></pre>
<p>You’d really expect it to give you back the same thing twice. This has what people have come to expect from math. It’s much the same argument that I made for immutability, with a pure function there’s all sorts of nice assumptions you can make about it, once again a function application is just becomes a name for the resulting value. This is different than a function call in python where the actual computation is important because it has side effects.</p>
<p>I said “primarily pure” because some things are really impure, the classic example being <code>readLine</code>.</p>
<pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">print</span> <span class="st">&quot;Enter your age:&quot;</span>;
    age = readLine();
    <span class="kw">print</span> <span class="st">&quot;Enter your height:&quot;</span>;
    height = readLine();</code></pre>
<p>Now if we’d hope that <code>age</code> and <code>height</code> contain different values. In Haskell we have monads for this, but those are notoriously hard to understand. Instead, pragmatic impurity is probably the best course for a beginner’s language. Much like Scheme.</p>
<h2 id="but-objects">But Objects!</h2>
<p>Now I know that someone is thinking, “But object orientation!!”. To them I say, you’re right: for some set of problems object orientation is a better model for a problem. But it’s a far smaller set of problems than you’d think.</p>
<p>It’s important for a beginner to be exposed to multiple paradigms, but I see no reason why the first paradigm shouldn’t be functional. In fact, I’ve outlined several reasons why it <em>should</em> be functional.</p>
<hr />
<h1 id="but-which-one">But Which One?</h1>
<p>So if you’re some random teen about to start functional programming, which language would you choose?</p>
<p>Some of the more popular languages that fit my definition of functional:</p>
<ul>
<li>Scheme/Racket</li>
<li>Clojure</li>
<li>Haskell</li>
<li>Erlang</li>
<li>Scala</li>
<li>SML</li>
<li>OCaml</li>
<li>F#</li>
</ul>
<p>Notice that most of the common “pseudo-functional” languages (JavaScript, Ruby, etc) fail the first constraint of immutability. I also chose to leave off some of the more research oriented languages (Coq, Agda, etc) because we’re talking about beginners here.</p>
<p>Now for a language to be good for a beginner it has to</p>
<ul>
<li>Not have an overly complicated type system</li>
<li>Have an implementation with good error messages</li>
<li>Have lots of libraries, particularly web/game frameworks</li>
<li>A batteries included standard library to get up and running with</li>
<li>Have good community support <strong>for newcomers</strong></li>
</ul>
<h3 id="haskell">Haskell</h3>
<p>We certainly can agree that Haskell is not a beginner’s language. Now Haskell is the language I write 99% of my code in and I’m saying this.</p>
<p>The type system, laziness, and monadic IO concept are all very daunting to a beginner. It doesn’t help that some of the error messages GHC produces are well… opaque. It’s not a bad language, but it’s not one that I would suggest for starting with.</p>
<h3 id="smlocaml">SML/OCaml</h3>
<p>Now SML and OCaml are both fine languages. But they don’t have the infrastructure to support a lot of teenage programmers.</p>
<p>They’re missing the game/GUI/web frameworks. They’re missing the tools. They’re missing the libraries. It’s just not there.</p>
<p>Other than that though, I see no reason why OCaml in particular wouldn’t make quite a reasonable language to start with. Pragmatically functional, reasonable type system, and strict semantics.</p>
<p>But the core language isn’t enough to make it a good first choice.</p>
<h3 id="scala">Scala</h3>
<p>Scala, like Haskell, is a very nice language that definitely fails the simplicity criteria. The type system is just as sophisticated as Haskell’s but with worse inference you have to be more explicit.</p>
<p>Again, it’s just not a language for a beginner from what I’ve seen.</p>
<p>Though with access to the java ecosystem and a very active community it nicely passes every other criteria.</p>
<h3 id="erlang">Erlang</h3>
<p>Erlang may be a nice language for a beginner. Once again I’ll admit ignorance and leave it to someone else to comment on it’s suitability.</p>
<p>I suspect that the focus on concurrency will make it a bit less intuitive to a beginner who doesn’t have any interest in those issues.</p>
<h3 id="racketscheme">Racket/Scheme</h3>
<p>Scheme on its own just fails the library support. It’s good for a classroom but for the demanding teenage hacker, the lack of game/gui frameworks is just killer.</p>
<p>Racket is a different story. Racket actually has a good set of libraries for GUI’s and games. It’s simple enough for a beginner. It has a good community for beginners, being made by educators.</p>
<p>In fact, the only problem I see with Racket vs Python is just the lack of hype. There isn’t the same marketing going on for Racket as Python, but there certainly could be.</p>
<p>Racket is what I recommend to people who are interested in starting with functional programming.</p>
<h3 id="clojure">Clojure</h3>
<p>I think Clojure is another strong choice. It’s just as simple as Racket and a much better community behind it.</p>
<p>It’s got all of Java’s libraries for games and several web frameworks of it’s own. In particular I’d love to see someone write a really slick DSL for minecraft in Clojure. It would be a great hook to say “Hey, come learn Clojure because it makes writing minecraft mods trivial”.</p>
<p>Maybe in the future I’ll start recommending Clojure instead of Racket. It looks like it’s got a brighter future with the much stronger community drive behind it.</p>
<hr />
<h1 id="conclusion">Conclusion</h1>
<p>So where does this leave us? Well I think the answer to the original question is clear. Functional programming isn’t the problem, functional languages are the problem.</p>
<p>There isn’t a clear analog to something like Python or Ruby in the functional programming world. I think it’s a legitimate niche for a language to try to fill too.</p>
<p>Perhaps I’ve overlooked something, but right now I think functional programming has got a ways to go making it more accessible to beginners. And I think it’s definitely worth the effort since a lot of the marketing points of FP, easier reasoning, simplified concepts, etc are all excellent for beginners.</p>

        </div>
        <div id="footer">
            Site generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
